# UP25 Lab03：GOTOKU 挑戰 — `LD_PRELOAD` 與 GOT 表操作

---

## 實驗目的

本次 Lab03 的核心目標是深入探討 **`LD_PRELOAD`** 環境變數的應用，並學習如何操作程式的 **GOT (Global Offset Table)** 表。我需要撰寫一個共享物件（`.so` 檔案），作為解題器上傳至遠端挑戰伺服器，最終自動解決一個 Sudoku 謎題。

## 實驗內容與重點

在這次實驗中，我將專注於以下幾個關鍵部分：

1.  **`LD_PRELOAD` 的運用**
    * 學習如何編寫一個共享物件（`libsolver.so`），並利用 `LD_PRELOAD` 機制，在主程式 (`gotoku`) 運行前載入我的解題器，從而實現對其行為的劫持。

2.  **GOT 表的修改**
    * 這是這次實驗最重要的一環。我需要學習在程式運行時，如何動態修改其 GOT 表。這樣可以改變特定函式（例如 `gop_*` 系列函式）的實際呼叫位址。
    * 同時，我也會處理 `Full RELRO` 保護機制對 GOT 表修改的影響，並學習使用 `mprotect(2)` 來調整記憶體區域的寫入權限。
    * 透過課程提供的 `game_get_ptr` 函式，我可以取得 `main` 函式的實際運行時位址，再結合 `pwntools` 靜態分析得到的偏移量，精確計算出 GOT 表中各項目的真實位址。

3.  **Sudoku 解題器開發**
    * 我將分析 `gotoku.c` 和 `libgotoku_dummy.c` 原始碼，了解 Sudoku 謎題的處理邏輯。
    * 接著，我會開發一個能自動解出 Sudoku 謎題的邏輯，並利用修改 GOT 表的方式，將 `gotoku` 程式對 `gop_NNN` 這些「無用」函式的呼叫，重導向到正確的移動（`gop_up`、`gop_down` 等）或填充數字（`gop_fill_[1-9]`）函式，最終解決謎題。

4.  **與挑戰伺服器互動**
    * 我需要學會使用 `nc` 命令連接到挑戰伺服器，並解決其前置的 PoW (Proof-of-Work) 挑戰。
    * 完成後，我將使用課程提供的 `submit.py` 腳本，將編譯好的 `x86_64` 架構 `libsolver.so` 上傳至伺服器。
    * 最終目標是確保我的解題器在伺服器上能自動完成整個 Sudoku 謎題，並取得最終的通關訊息。


## 心得

Lab03 是一個相當具有挑戰性的實驗，它讓我能夠實作底層的記憶體操作，並將其應用於解決實際問題。理解 `LD_PRELOAD` 和 GOT 表的原理，並能實際操作它們來改變程式執行流程，這對於我深入理解作業系統底層機制和資安領域的知識非常有幫助。