---

# UP25 Lab06: 緩衝區溢位與殼層編碼挑戰

本儲存庫記錄了 UP25 Lab06 的解決方案，內容涵蓋緩衝區溢位 (Buffer Overflow)、殼層編碼 (Shellcoding) 與返回導向程式設計 (Return-Oriented Programming, ROP) 等漏洞利用技術。

## 實驗概述

此實驗包含四個挑戰，旨在利用程式漏洞來讀取伺服器上的 `/FLAG` 檔案。

*   **Challenge #1: 基本 Shellcode**
    *   **目標**: 在 Seccomp 沙盒限制下，撰寫並執行一段 x86_64 shellcode 以讀取並輸出 FLAG。

*   **Challenge #2: 基礎緩衝區溢位**
    *   **目標**: 利用緩衝區溢位，跳轉到 `msg` 緩衝區中可執行的 shellcode。
    *   **核心**: 需先洩漏程式基底位址 (PIE Base) 以計算 `msg` 的執行時位址。

*   **Challenge #3: 繞過 Canary 保護**
    *   **目標**: 與 Challenge #2 類似，但增加了 Canary 保護。
    *   **核心**: 在覆寫返回位址前，必須先洩漏 Canary 的值，並在最終 payload 中將其原封不動地放回。

*   **Challenge #4: 返回導向程式設計 (ROP)**
    *   **目標**: 在無法直接執行 shellcode 的環境下 (NX 保護)，利用 ROP 鏈來實現讀取並輸出 FLAG 的功能。
    *   **核心**: 尋找程式中現有的指令片段 (gadgets)，並將它們的位址串連在堆疊上，以模擬系統呼叫。

## 遇到的挑戰與解決策略

1.  **位址空間佈局隨機化 (ASLR/PIE)**
    *   **問題**: 程式基底位址隨機，無法硬編碼跳轉目標。
    *   **策略**: 利用 `printf` 等輸出函式的漏洞洩漏堆疊上的返回位址 (Saved RIP)，藉此計算出程式的 PIE Base，進而推算出所有需要的執行時位址。

2.  **Canary 堆疊保護**
    *   **問題**: 直接覆寫返回位址會因破壞 Canary 值而導致程式崩潰。
    *   **策略**: 同樣利用資訊洩漏，先精確地洩漏出 Canary 的值。在最終的攻擊 payload 中，於正確的偏移位置填入洩漏到的 Canary，以繞過檢查。

3.  **單次連線中的資訊洩漏與利用**
    *   **問題**: 遠端伺服器可能為每個 TCP 連線啟動新程序，導致 ASLR 使前一次連線洩漏的位址失效。
    *   **策略**: 在單次連線中完成所有操作。這通常需要更精巧的設計，例如：
        *   **一次性洩漏多個資訊**: 在 Challenge #3 中，發現 Canary 的最低位元組非 `\x00`，使得一次 `printf` 呼叫就能同時洩漏 Canary 和返回位址。
        *   **多階段輸入**: 利用程式中多次 `read` 的機會，分階段洩漏 Canary、返回位址，並在最後一次輸入時發動總攻擊。

4.  **NX (No-Execute) 保護與 ROP**
    *   **問題**: 堆疊和資料段不可執行，無法直接跳轉到注入的 shellcode。
    *   **策略**: 使用 ROP 技術。透過 `ROPgadget` 工具或 `pwntools` 的 `ROP` 類別，在程式碼中尋找可用的 gadgets (`pop rdi; ret` 等)，並將它們的位址和參數組合成 ROP 鏈，以模擬系統呼叫，達成與 shellcode 相同的目的。

---